/*
 * The code is automatically generated by the Goland.
 * Copyright © Aquarian-Age. All Rights Reserved.
 * Licensed under MIT
 */

package pub

import (
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/starainrt/astro/calendar"
)

// GetGanS 取天干 传干支 返回干
func GetGanS(gz string) string {
	gan := [11]string{"甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"}
	var g string
	for i := 0; i < len(gan); i++ {
		if strings.ContainsAny(gz, gan[i]) {
			g = gan[i]
			break
		}
	}
	return g
}

// GetZhiS 取地支 传干支返回支
func GetZhiS(gz string) string {
	zhi := []string{"子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"}
	var z string
	for i := 0; i < len(zhi); i++ {
		if strings.ContainsAny(gz, zhi[i]) {
			z = zhi[i]
			break
		}
	}
	return z
}

// SortArr 顺序排地支 传入对应的地支 原地支数组 返回排序后的地支数组
func SortArr(zhi string, zhiArr []string) []string {
	for i := 0; i < len(zhiArr); i++ {
		if strings.EqualFold(zhi, zhiArr[i]) {
			head := zhiArr[:i]
			end := zhiArr[i:]
			zhiArr = append(end, head...)
			break
		}
	}
	return zhiArr
}

// ReSortArr 逆序排地支
func ReSortArr(zhi string, zhiArr []string) []string {
	for i := 0; i < len(zhiArr); i++ {
		if strings.EqualFold(zhi, zhiArr[i]) {
			head := zhiArr[:i]
			end := zhiArr[i:]
			zhiArr = append(end, head...)
			break
		}
	}
	//
	head := zhiArr[:1]
	end := zhiArr[1:]
	var rArr []string
	for i := len(end) - 1; i >= 0; i-- {
		rArr = append(rArr, end[i])
	}
	rArr = append(head, rArr...)
	return rArr
}

// ReName 顺序不变　把arr数组中source名字改为source + add 如果没有符合条件的返回原值
func ReName(arr []string, source, add string) []string {
	var newArr []string
	for i := 0; i < len(arr); i++ {
		if strings.EqualFold(arr[i], source) {
			source = source + add
			head := arr[:i+1]
			head = head[:len(head)-1]
			head = append(head, source)
			end := arr[i+1:]
			newArr = append(head, end...)
		} else {
			newArr = arr
		}
	}
	return newArr
}

// ReNameS 正则替换 把s的dels元素替换成r
func ReNameS(s, dels string, r string) string {
	rs, err := regexp.Compile(dels)
	if err != nil {
		log.Fatal(err)
	}
	return rs.ReplaceAllString(s, r)
}

// SortArrInt 顺排 int数组 排序后使得index在首位 返回排序后的数组 如果index不在数组中 返回错误
func SortArrInt(index int, arr []int) ([]int, error) {
	var err error
	for i := 0; i < len(arr); i++ {
		if index == arr[i] {
			head := arr[i:]
			end := arr[:i]
			arr = append(head, end...)
			return arr, nil
		} else if index != arr[i] {
			err = fmt.Errorf("%d不在数组%d中", index, arr)
		}
	}
	return arr, err
}

// SortInt 正向排序
func SortInt(index int, arr []int) []int {
	var xarr []int
	for i := 0; i < len(arr); i++ {
		if index == arr[i] {
			head := arr[i:]
			end := arr[:i]
			xarr = append(head, end...)
			break
		}
	}
	return xarr
}

// ReSortArrInt 逆向排序
func ReSortArrInt(index int, arr []int) []int {
	for i := 0; i < len(arr); i++ {
		if index == arr[i] {
			head := arr[i:]
			end := arr[:i]
			arr = append(head, end...)
			break
		}
	}
	head := arr[:1]
	end := arr[1:]
	var rArr []int
	for i := len(end) - 1; i >= 0; i-- {
		rArr = append(rArr, end[i])
	}
	rArr = append(head, rArr...)
	return rArr
}

// WeekName 周几 0,7周日　1:周一
func WeekName(n int) (w string) {
	switch n {
	case 0, 7:
		w = "周日"
	case 1:
		w = "周一"
	case 2:
		w = "周二"
	case 3:
		w = "周三"
	case 4:
		w = "周四"
	case 5:
		w = "周五"
	case 6:
		w = "周六"
	}
	return
}

// DelElement 去除切片空元 同时去除切片的相同元素
func DelElement(s []string) []string {
	news := []string{}
	for _, v := range s {
		if len(v) > 0 {
			news = append(news, v)
		}
	}
	news = RemoveRepeatedElement(news)
	return news
}

// RemoveRepeatedElement 去除重复元素
func RemoveRepeatedElement(arr []string) (newArr []string) {
	newArr = make([]string, 0)
	for i := 0; i < len(arr); i++ {
		repeat := false
		for j := i + 1; j < len(arr); j++ {
			if arr[i] == arr[j] {
				repeat = true
				break
			}
		}
		if !repeat {
			newArr = append(newArr, arr[i])
		}
	}
	return newArr
}

// JueLiRi XJBF四离四绝
// 离 冬至 夏至 春分 秋分 前一日
// 绝 立春 立夏 立秋 立冬 前一日
// st :阳历当日时间戳 jqt:节气时间戳数组
func JueLiRi(st time.Time) (sjs string) {
	st = time.Date(st.Year(), st.Month(), st.Day(), 0, 0, 0, 0, time.Local) //时间精确到日
	lichunt := calendar.JieQi(st.Year(), calendar.JQ_立春)                    //立春日 jqt[3]
	lixiat := calendar.JieQi(st.Year(), calendar.JQ_立夏)                     //立夏 jqt[9]
	liqiut := calendar.JieQi(st.Year(), calendar.JQ_立冬)                     //立秋 jqt[15]
	lidongt := calendar.JieQi(st.Year(), calendar.JQ_立冬)                    //立冬 jqt[21]

	chunfent := calendar.JieQi(st.Year(), calendar.JQ_春分) //春分 jqt[6]
	xiazhit := calendar.JieQi(st.Year(), calendar.JQ_夏至)  //夏至 jqt[12]
	qiufent := calendar.JieQi(st.Year(), calendar.JQ_秋分)  //秋分 jqt[18]
	dongzhit := calendar.JieQi(st.Year(), calendar.JQ_冬至) //冬至  jqt[24]
	//绝
	lichunt = time.Date(lichunt.Year(), lichunt.Month(), lichunt.Day(), 0, 0, 0, 0, time.Local)
	lixiat = time.Date(lixiat.Year(), lixiat.Month(), lixiat.Day(), 0, 0, 0, 0, time.Local)
	liqiut = time.Date(liqiut.Year(), liqiut.Month(), liqiut.Day(), 0, 0, 0, 0, time.Local)
	lidongt = time.Date(lidongt.Year(), lidongt.Month(), lidongt.Day(), 0, 0, 0, 0, time.Local)
	//离
	chunfent = time.Date(chunfent.Year(), chunfent.Month(), chunfent.Day(), 0, 0, 0, 0, time.Local)
	xiazhit = time.Date(xiazhit.Year(), xiazhit.Month(), xiazhit.Day(), 0, 0, 0, 0, time.Local)
	qiufent = time.Date(qiufent.Year(), qiufent.Month(), qiufent.Day(), 0, 0, 0, 0, time.Local)
	dongzhit = time.Date(dongzhit.Year(), dongzhit.Month(), dongzhit.Day(), 0, 0, 0, 0, time.Local)

	nst := time.Date(st.Year(), st.Month(), st.Day()+1, 0, 0, 0, 0, time.Local)

	if nst.Equal(lichunt) || nst.Equal(lixiat) || nst.Equal(liqiut) || nst.Equal(lidongt) {
		sjs = "绝日"
	}
	if nst.Equal(chunfent) || nst.Equal(xiazhit) || nst.Equal(qiufent) || nst.Equal(dongzhit) {
		sjs = "离日"
	}
	return
}

// JiTanBing 忌探病日
func JiTanBing(dgz string) (jtb string) {
	arrs := []string{"壬寅", "壬午", "庚午", "甲寅", "乙卯", "己卯"}
	for i := 0; i < len(arrs); i++ {
		if strings.EqualFold(dgz, arrs[i]) {
			jtb = "忌探病"
			break
		}
	}
	return
}
